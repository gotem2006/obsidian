Для начала нужно знать, что существуют два пространства для хранения памяти: **куча** и **стек**. Если данные попадают в стек, это лучший вариант, так как в нем заложен автоматизированный процесс очистки памяти, работает по принципу LIFO(last in first out). А в случае с кучей используется отдельный процесс очистки памяти — **GC (garbage collector)**.

Куда именно будет выделена память для переменной, определяет механизм **escape analysis**. В общем случае, **все объекты, на которые могут быть ссылки, аллоцируются в куче**, а **все локальные переменные — в стеке**.

Однако есть один особый случай с массивами и слайсами:

- Если **слайс** занимает **больше 64 КБ**, он будет аллоцирован в **куче**.
- Если **массив** занимает **больше 10 МБ**, он тоже будет аллоцирован в **куче**.
Что бы проверить где аллоцируется переменная можно воспользоваться командой:
```
go run -gcflags "-m" main.go
```
Также нужно знать, что можно управлять аллокацией памяти. Прямых инструментов для этого у нас нет, как в C++, но существуют такие механизмы, как Pool и Arena. Они служат для повторного использования памяти и удаления объектов, когда это необходимо самим разработчиком.

Разница между Pool и Arena заключается в том, что Arena может работать с разными типами, тогда как Pool предназначен для работы с одним конкретным типом.