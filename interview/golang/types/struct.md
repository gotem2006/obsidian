Структура (struct) в Go — это базовый составной тип, который позволяет объединять связанные данные в один логический объект. Вот несколько ключевых особенностей работы со структурами в Go:


1. Ресивер — это указатель в методе структуры. Его применение позволяет изменять данные структуры внутри метода. Например:

```go
type car struct 
{ 	
Gas int 
}
func (c *car) /* <- применение того самого ресивера */ AddGas(gasPoint int) {

	c.Gas += gasPoint // благодаря использованию указателя (ресивера) структура изменит значение 
}
```
2. В Go нет наследования в классическом понимании, но можно встраивать одну структуру в другую. Это позволяет переопределять методы родительской структуры. Например:
```go
type lada struct { 	
	Speed int 	
	Color string 	
	HP    int 
}  

func (l *lada) Init() { 	
	l.Speed = 0 	
	l.Color = "white" 	
	l.HP = 105 
}  

type lambo struct { 	
	lada 
}  

func (l *lambo) Init() { 
	l.Speed = 0 	
	l.Color = "red" 	
	l.HP = 1000 
}
```

В данном случае `lambo` включает в себя `lada`, но при этом метод `Init()` можно переопределить под нужды `lambo`.
3.  Процессор автоматически выравнивает память для ускорения доступа к данным, и неправильный порядок объявления полей может привести к неэффективному использованию памяти.

**Неоптимальный вариант (занимает больше памяти из-за выравнивания):**

```go
type lambo struct { 	
	Speed    int32 	// занимает 4 байта
	Broken   bool // весит один байт но из-за выравнивания памяти будет весить 4 байта 
	Hp int32 // 4 bytes
 	Launched bool // 4 bytes по той же причине что и выше
	
} // total 16 bytes
```

**Оптимальный вариант (экономит память за счёт группировки одинаковых типов):**
```go
type lambo struct { 	
	Broken   bool 	// 2 bytes
	Launched bool 	// 2 bytes
	Speed    int32 // 4 bytes 
	Hp       int32 // 4 bytes
}    // total 12 bytes 

```
Правильный порядок объявления полей позволяет минимизировать количество паддингов (неиспользуемых байтов, добавляемых для выравнивания).
