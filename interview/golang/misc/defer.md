Используется для отложенного выполнения в функции перед `return`, работает по принципу очереди **LIFO (Last In, First Out)**. Захватывает значение на данный момент.
```go
import "fmt"

func main(){
	a := 5
	defer fmt.Println(a) // не смотря на то что выполниться в конце main() 
	//выведет 5
	a += 10
}
```
Чтобы захватывать изменённое значение после `defer`, удобно использовать анонимную функцию:
```go
import "fmt"

func main(){
	a := 5
	
	defer func(){
		fmt.Println(a) // уже выведет 15
	}()
	
	a += 10
}
```
Также нужно понимать, как будет работать `defer` с несколькими вызовами:
```go
import "fmt"

func main(){

	a := 5
	defer func(){
		fmt.Println(a)
	}()
	defer func(){
		a = a / 10
	}()
	defer func(){
		a = a + 5
	}()
}


```
Сработает он в **обратном порядке**, то есть по принципу **LIFO (Last In, First Out)**. Выполнение будет таким:

1. `a = a + 5` → `a = 10`
2. `a = a / 10` → `a = 1`
3. `fmt.Println(a)` → выведет `1`