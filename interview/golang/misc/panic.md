В **Go** паника (_panic_) — это фатальная ошибка, из-за которой приложение немедленно завершит свою работу. Паника может быть вызвана самостоятельно с помощью функции:
```go
panic("")
```
Когда происходит паника, программа начинает сворачиваться, выполняя _defer_-функции (если они есть), после чего полностью завершает работу.

### Восстановление после паники: `recover`

В `Go` есть инструмент для отлова паники и восстановления контроля над приложением — это функция `recover()`. Она позволяет перехватить панику внутри `defer` и продолжить выполнение программы без аварийного завершения.

Пример использования `recover`:
```go
package main

import "fmt"

func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Поймали панику:", r)
        }
    }()

    fmt.Println("До паники")
    panic("что-то сломалось")
    fmt.Println("После паники (не выполнится)")
}

```
В этом коде:

- Мы используем `defer` для отложенного вызова анонимной функции.
- Внутри нее вызываем `recover()`, который перехватывает панику.
- Если `recover()` возвращает `nil`, значит паники не было.
- Если вернулось значение, значит паника произошла, и мы можем обработать её.

Таким образом, `recover` позволяет избежать полного падения программы и выполнить корректную обработку ошибки. Однако злоупотреблять `recover` не стоит — он не заменяет правильное использование _error-handling_ через `error`.