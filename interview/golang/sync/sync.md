
Примитивы синхронизации — это механизмы, которые помогают управлять конкурентным доступом к данным в многопоточной среде. Они применяются для решения таких проблем, как **гонка данных (data race)** и **завершение главной горутины раньше дочерних**.

Один из таких примитивов — **каналы (channels)**. Помимо синхронизации, они позволяют передавать данные между горутинами, что делает их удобным инструментом для организации конкурентных программ.

Другой важный примитив — **sync.WaitGroup**. Он используется для ожидания завершения всех горутин перед тем, как продолжить выполнение основного потока.

### Использование `sync.WaitGroup`

Если запустить следующую программу:

```go
func main() {
	go func() {
		fmt.Println(1)
	}()
}
```

Вывод может не появиться, потому что `main`-функция завершится раньше, чем горутина успеет выполниться.

Решение этой проблемы — использование `sync.WaitGroup`. Он работает как счётчик активных горутин: когда все горутины завершились, программа продолжает выполнение.

Пример с `sync.WaitGroup`:

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(1) // Увеличиваем счетчик горутин

	go func() {
		defer wg.Done() // После выполнения уменьшаем счетчик
		fmt.Println(1)
	}()

	wg.Wait() // Ожидаем, пока счетчик дойдет до нуля
}

```
### `sync/atomic` — атомарные операции

Внутри `WaitGroup` используется другой примитив синхронизации — **атомарные операции**, предоставляемые пакетом `sync/atomic`. Атомарные операции выполняются на уровне процессора и позволяют изменять переменные без блокировок.

Пример использования `sync/atomic`:

```go
package main

import (
	"fmt"
	"sync/atomic"
	"time"
)

func main() {
	var counter atomic.Int64

	for i := 0; i < 30; i++ {
		go func() {
			counter.Add(1) // Атомарное увеличение переменной
		}()
	}

	time.Sleep(time.Millisecond) // Даем время горутинам выполниться
	fmt.Println(counter.Load())  // Получаем актуальное значение
}

```
### Почему `atomic`?

Гонка данных возникает, когда несколько горутин одновременно читают и изменяют одну и ту же переменную без синхронизации. Это приводит к некорректным значениям. `sync/atomic` решает эту проблему, обеспечивая **атомарность** операций — они выполняются за одну инструкцию процессора.

Однако `sync/atomic` поддерживает только базовые типы (`int64`, `uint64`, `Pointer` и т. д.). Для более сложных структур данных используются **мьютексы (Mutex) и RWMutex**.

### `sync.Mutex` и `sync.RWMutex`

Мьютекс (`sync.Mutex`) блокирует доступ к ресурсу, пока один поток его использует. `sync.RWMutex` позволяет множеству потоков **читать** данные одновременно, но блокирует запись.

Пример с `sync.Mutex`:
```go
package main

import (
	"fmt"
	"sync"
)

var (
	users = make(map[int]string)
	mu    sync.Mutex
)

func main() {
	names := []string{"Alice", "Bob", "Colya", "Lydik", "Dvynya"}
	var counter int

	for _, name := range names {
		mu.Lock()
		users[counter] = name
		counter++
		mu.Unlock()
	}

	fmt.Println(users)
}

```

[^1]: 
