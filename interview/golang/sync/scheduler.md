Асинхронность стала возможной благодаря развитию более мощных компьютеров. Это концепция, объединяющая **параллелизм** и **конкурентность**.

- **Параллелизм** означает, что у нас есть несколько физических ресурсов (например, ядер процессора), которые могут выполнять задачи одновременно.
- **Конкурентность** подразумевает, что один ресурс (например, поток выполнения) переключается между несколькими задачами, создавая эффект одновременной работы.

В совокупности это позволяет нам использовать несколько ресурсов, работающих параллельно, при этом каждый ресурс выполняет разные задачи, переключаясь между ними.

Ранее, до появления многоядерных процессоров, была доступна только конкурентность, поскольку у процессора было одно ядро, и оно могло лишь быстро переключаться между задачами. Однако благодаря увеличению числа ядер стало возможно полноценное параллельное выполнение задач, что значительно повысило производительность.

Эта концепция активно применяется в **Golang**. В операционных системах есть встроенная реализация потоков (threads), но у нее есть недостаток: **контекстное переключение (context switching)** между потоками требует взаимодействия с ядром ОС (_kernel space_). Это приводит к частому сбросу кешей процессора, что негативно сказывается на производительности.

Разработчики **Golang** решили создать свою абстракцию над этой моделью, где управление потоками берет на себя **runtime Golang**, а в _kernel space_ передается только то, что действительно необходимо. Эта модель называется **GMP-моделью**, где:

- **G** — горутина (_goroutine_) — легковесный поток выполнения, управляемый самим Go.
- **M** — машинный поток (_machine thread_) — системный поток ОС, на котором исполняются горутины.
- **P** — планировщик (_processor_, не связанный напрямую с физическими процессорами) — отвечает за распределение горутин по потокам.

### Как работает GMP-модель

1. При запуске программы создается определенное число **P** (по умолчанию — равное числу логических процессоров).
2. Каждому **P** назначается очередь горутин, которые нужно выполнить.
3. Машинные потоки **M** берут горутины из **P** и выполняют их.
4. Если горутина блокируется (например, ждет ввода/вывода), **P** может передать выполнение другой горутины, не блокируя поток **M**.
5. Если у одного **P** нет задач, он может "украсть" (_work stealing_) горутины из очереди другого **P**.
В Go для оптимизации работы с системными вызовами (например, сетевыми запросами или операций чтения/записи в файл) горутина будет выполняться в отдельном потоке. Однако в случае с сетевыми запросами в каждой ОС есть специальный механизм **netpoller** (например, в Linux), который обрабатывает эти горутины. После завершения работы такие горутины отправляются в **глобальную очередь**.

### Глобальная очередь и её роль в планировщике Go

1. Горутины попадают в **глобальную очередь** в нескольких случаях:
    
    - После выполнения системного вызова.
    - Когда локальная очередь переполняется: если в неё поступает слишком много горутин, **половина из них** отправляется в глобальную очередь.
2. Локальные очереди обращаются к глобальной **в последнюю очередь**:
    
    - Если **локальная очередь потока (P) пустеет**, он начинает "красть" задачи у других потоков.
    - Если и там нет задач, он обращается к **глобальной очереди**.
    - Чтобы горутины в глобальной очереди не простаивали, **каждые 61 переключение задач планировщик заглядывает в глобальную очередь**, чтобы взять оттуда задачи.

### Корпоративная многозадачность в Go

В Go используется **кооперативная многозадачность**, что означает, что **горутины сами передают управление** в двух случаях:

1. Когда завершили свою работу.
2. Когда ушли на паузу (например, ожидают данные из канала, блокируются на мьютексе, выполняют I/O и т.д.).

Однако начиная с одной из версий Go, появился механизм **sysmon**. Он следит за выполнением горутин и, если какая-то горутина выполняется **дольше 10 мс**, планировщик передаёт управление следующей горутине, чтобы избежать зависаний.
Поэтому многозадачность в golang является корпоративно вытесняющей.
![[Pasted image 20250307234006.png]]